{% for namespace in repr.namespaces %}

namespace {{ namespace.name }} {
{% for trait in namespace.traits %}

{{ export }}struct {{ trait.name }} : di::Trait
{
    {% for method_name in trait.method_names %}
    DI_METHOD_TAG({{ method_name }})
    {% endfor %}

    template<di::IsMethodOf<{{ trait.name }}> Tag>
    friend constexpr {{ trait.name }} traitOf(Tag) { return {}; }

    struct Meta
    {
        struct Applicable
        {
            {% for method_name in trait.method_names %}
            DI_METHOD_TAG_APPLICABLE({{ method_name }})
            {% endfor %}
        };
        struct Methods
        {
            {% for method_name in trait.method_names %}
            DI_AS_FUNCTOR_METHOD({{ method_name }})
            {% endfor %}

            {% for method in trait.methods %}
            template<di::IsTraitView Self
                {%- for prefix, name in method.templates -%}
                , {{ prefix }}{{ prefix.pack }} {{ name }}
                {%- endfor -%}
                {%- if trait.types_name -%}
                , class {{ trait.types_name }} = std::remove_cvref_t<Self>::Types
                {%- endif -%}
                {%- if trait.root_name -%}
                , class {{ trait.root_name }} = di::ResolveRoot<di::ContextOf<std::remove_cvref_t<Self>>>
                {%- endif -%}
                {%- if trait.info_name -%}
                , class {{ trait.info_name }} = di::ResolveInfo<di::ContextOf<std::remove_cvref_t<Self>>>
                {%- endif -%}
                {%- if trait.impl_named -%}
                , class {{ trait.impl_name }} = std::remove_cvref_t<Self>::Traits::Node
                {%- endif -%}
            >
            DI_INLINE constexpr auto {{ method.name }}(this Self{{ " const&" if method.is_const else "&&" }} self
                {%- for type, name in method.params -%}
                , {{ type }}{{ type.pack }} {{ name }}
                {%- endfor -%}
            ){{ " -> " + method.return_type.str if method.return_type.str != "auto" else "" }}
            {
                return self.impl({{ method.name }}_c
                    {%- for type, name in method.params -%}
                    , DI_FWD({{ name }}){{ type.pack }}
                    {%- endfor -%}
                );
            }
            {% endfor %}
        };
        struct DuckMethods
        {
            {% for method_name in trait.method_names %}
            DI_DUCK_METHOD({{ method_name }})
            {% endfor %}
        };
    };

    template<class Self, class {{ trait.impl_name }}, class {{ trait.types_name or "" }}
    {%- if trait.root_name -%}
        , class {{ trait.root_name }} = di::ResolveRoot<di::ContextOf<{{ trait.impl_name }}>>
    {%- endif -%}
    {%- if trait.info_name -%}
        , class {{ trait.info_name }} = di::ResolveInfo<di::ContextOf<{{ trait.impl_name }}>>
    {%- endif -%}
    >
    requires requires ({{ trait.impl_name }} impl_, {{ trait.impl_name }} const const_)
    {
        typename {{ trait.impl_name }}::Traits;
        {% for require in trait.requires %}
        {{ require }}
        {% endfor %}
        {% for method in trait.methods if not method.is_template and not method.optional %}

        {% macro require_invoke() -%}
            {{ "const_" if method.is_const else "impl_" }}.impl({{ method.name }}_c
                {%- for type, name in method.params -%}
                , DI_FWD({{ name }})
                {%- endfor -%}
            )
        {%- endmacro %}
        {% set comma = joiner(", ") %}
        requires requires (
            {%- for type, name in method.params -%}
            {{ comma() }}{{ type }} {{ name }}
            {%- endfor -%}
            {%- if not method.is_unconstrained_return and not method.is_auto_return -%}
            {{ comma() }}{{ method.return_type }} _return_type_
            {%- endif -%}
            ) {
        {% if method.is_unconstrained_return %}
            {{ require_invoke() }};
        {% elif method.is_auto_return %}
            { {{ require_invoke() }} } -> {{ method.return_type.str.removesuffix("auto") }};
        {% else %}
            { {{ require_invoke() }} } -> std::convertible_to<decltype(_return_type_)>;
        {% endif %}
        };
        {% endfor %}
    }
    using Implements = void;
} inline constexpr {{ trait.variable }}{};
{% endfor %}
{% for alias in namespace.trait_aliases %}

{% if alias | count == 2 %}
{{ export }}using {{ alias[0] }} = di::AltTrait<{{ alias[1] }}, struct {{ alias[0] }}_Tag>;
{% else %}
{{ export }}using {{ alias[0] }} = di::JoinedTrait<{{ alias[1:] | join(", ") }}>;
{% endif %}
{{ export }}inline constexpr {{ alias[0] }} {{ alias[0][0].lower() + alias[0][1:] }}{};
{% endfor %}
{% for cluster in namespace.clusters %}

{% if not cluster.templates %}
template<class Context>
struct {{ cluster.node_name() }};
{{ export }}using {{ cluster.name }} = di::InlineNode<{{ cluster.node_name() }}>;
{% else %}
{{ export }}template<
    {%- set comma = joiner(", ") -%}
    {%- for prefix, name in cluster.templates -%}
    {{ comma() }}{{ prefix }}{{ prefix.pack }} {{ name }}
    {%- endfor -%}
>
struct {{ cluster.name }}
{
    template<class Context>
    struct {{ cluster.node_name() }};
};
{% endif %}
{% endfor %}

} // namespace {{ namespace.name }}
{% endfor %}
{% for namespace in repr.namespaces if namespace.clusters %}

namespace {{ namespace.name }} {
{% for cluster in namespace.clusters %}

{% if cluster.templates %}
template<
    {%- set comma = joiner(", ") -%}
    {%- for prefix, name in cluster.templates -%}
    {{ comma() }}{{ prefix }}{{ prefix.pack }} {{ name }}
    {%- endfor -%}
>
template<class {{ cluster.context_name }}>
struct {{ cluster.name }}<
    {%- set comma = joiner(", ") -%}
    {%- for prefix, name in cluster.templates -%}
    {{ comma() }}{{ name }}{{ prefix.pack }}
    {%- endfor -%}
>::Node : {{ cluster.cluster_type }}
{% else %}
template<class {{ cluster.context_name }}>
struct {{ cluster.node_name() }} : {{ cluster.cluster_type }}
{% endif %}
{
    using Depends = di::Depends<{{ cluster.dependencies | join(", ") }}>;

    {% if 1 == cluster.nodes | length %}
    static constexpr bool isUnary()
    {
        return decltype({{ cluster.nodes.0.name }})::isUnary();
    }

    {% endif %}
    {% if cluster.root_name %}
    using {{ cluster.root_name }} = di::ResolveRoot<{{ cluster.context_name }}>;
    {% endif %}
    {% if cluster.info_name %}
    using {{ cluster.info_name }} = di::ResolveInfo<{{ cluster.context_name }}>;
    {% endif %}
    {% for node in cluster.nodes %}
    struct {{ node.context }};
    using {{ node.node_alias }} = {{ node.impl }};
    {% endfor %}
    {% if cluster.aliases %}

    {% for alias, type in cluster.aliases %}
    using {{ alias }} = {{ type }};
    {% endfor %}
    {% endif %}
    {% if cluster.parent_node.connections %}

    {% for connection in cluster.parent_node.connections %}
    {% if connection.is_renaming() %}
    DI_LINK(({{ connection.trait }}), {{ connection.context }}, ({{ connection.to_trait }}))
    {% else %}
    DI_LINK(({{ connection.trait }}), {{ connection.context }})
    {% endif %}
    {% endfor %}
    {% endif %}

    {% for node in cluster.nodes %}
    struct {{ node.context }} : di::Context<{{ cluster.node_name() }}, {{ node.context }}Node_>
    {
        {% for connection in node.connections %}
        {% if connection.is_renaming() %}
        DI_LINK(({{ connection.trait }}), {{ connection.context }}, ({{ connection.to_trait }}))
        {% else %}
        DI_LINK(({{ connection.trait }}), {{ connection.context }})
        {% endif %}
        {% endfor %}
    };
    {% endfor %}

    {% for node in cluster.nodes %}
    DI_NODE({{ node.context }}, {{ node.name }}{{ cluster.predicates_str(node) }})
    {% endfor %}

    constexpr void visit(this auto& self, auto&& visitor)
    {
        {% if 1 == cluster.user_nodes | length %}
        self.{{ cluster.user_nodes.0.name }}.visit(DI_FWD(visitor));
        {% else %}
        {% for node in cluster.user_nodes %}
        self.{{ node.name }}.visit(visitor);
        {% endfor %}
        {% endif %}
    }
};
{% endfor %}

} // namespace {{ namespace.name }}
{% endfor %}
